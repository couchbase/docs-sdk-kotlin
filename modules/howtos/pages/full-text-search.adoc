= Full Text Search
:description: You can use the Full Text Search (FTS) service to find JSON documents that have certain words, phrases, or geographic coordinates.
:navtitle: Full Text Search
:page-topic-type: howto
:page-toclevels: 2
include::project-docs:partial$attributes.adoc[]

[abstract]
{description}

The Full Text Search (FTS) service finds JSON documents that have certain words, phrases, or geographic coordinates.
It can also search for numbers and dates.

TIP: If you only need to search for numbers or dates, it might be better to use a N1QL query.

When searching for words and phrases, you can look for an exact match or similar words (like "beauty" and "beautiful").
For numbers and dates, you can look for values in a range.
For geographic coordinates, you can look for values near a location or within a region.

For all kinds of FTS searches, you can ask the server to count the number of matching documents that belong to different categories, called "facets."

[#prerequisites]
== Before You Start

You should know xref:{version-server}@server:fts/fts-creating-indexes.adoc[how to create a Full Text Search index].

You should know xref:howtos:connecting.adoc[how to connect to a Couchbase cluster].

The examples on this page use the `travel-sample` and `beer-sample` xref:{version-server}@server:manage:manage-settings/install-sample-buckets.adoc[sample buckets].

[#simple-example]
== A Simple FTS Search

This example searches for documents that have the word "pool" in one of the indexed fields.

If you want to run this example, first create an index called `travel-sample-index` on the `travel-sample` bucket.
Then run:

[source,kotlin]
----
include::example$FullTextSearch.kt[tag=simpleQuery,indent=0]
----
<1> The argument to `queryString` uses the same syntax as when you search an index using the Couchbase web UI.
`SearchQuery` has other companion factory methods for doing different kinds of searches.

[#query-types]
== Queries

The FTS service can do xref:{version-server}@server:fts/fts-supported-queries.adoc[many kinds of queries].
The Kotlin SDK's `SearchQuery` class has a companion factory method for each kind of query.

[#scoring]
== Scoring

The server gives each row a score.
A higher score means the row is a better match.

Calculating the score takes time.
If you don't need the score, tell the server to give each row a score of zero, like this:

NOTE: Disabling scoring requires Couchbase Server 6.6.1 or later.

.Disable scoring
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=disableScoring,indent=0]
----
<1> This line tells the server you don't care about scores.

[#sorting]
== Sorting

By default, result rows are sorted by score, from highest to lowest.
Use the `sort` parameter to tell the server to sort the rows differently.

This example sorts the results by the value of the "country" field:

.Sort by `country` field
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=sortByCountry,indent=0]
----
<1> `byField` also has optional parameters.
We will talk about them next.

`SearchSort` has companion factory methods for creating `SearchSort` objects.
These objects tell the server how to sort the results.

[#sorting-by-field]
=== Sorting by field value

`SearchSort.byField` tells the server to sort the rows using the value of a document field.

Required parameter:

* `field` -- Name of the field to use.

Optional parameters:

* `direction` -- Can be `ASCENDING` (A to Z) or `DESCENDING` (Z to A).
The default direction is `ASCENDING`.

* `missing` -- Tells the server where to put rows that don't have a value for the field.
Can be `FIRST` or `LAST`.
The default is `LAST`.

* `type` -- The type of the field.
Can be `STRING`, `NUMBER`, `DATE`, or `AUTO`.
The default type is `AUTO`, which tells the server to infer the type.

* `mode` -- A field can have more than one value.
This happens if the value is an array, or if the value is a string that is analyzed as more than one token.
The `mode` parameter tells the server which value to use for sorting.
If a field does not have more than one value, this parameter does nothing.
Possible values:
** `MIN` -- Use the minimum value.
** `MAX` -- Use the maximum value.
** `DEFAULT` -- The server will sort the rows the same way every time, but you won't know which value (or values) it used for sorting.
+
The default mode is `DEFAULT`.

[#sorting-by-score]
=== Sorting by score

`SearchSort.byScore` tells the server to sort the rows using each row's score.

Optional parameters:

* `direction` -- `ASCENDING` (low to high) or `DESCENDING` (high to low).
The default direction is `DESCENDING`.

[#sorting-by-id]
=== Sorting by document ID

The `SearchSort.byId` companion factory method creates a `SearchSort` object that tells the server to sort the rows using each row's document ID.

Optional parameters:

* `direction` -- `ASCENDING` (A to Z) or `DESCENDING` (Z to A).
The default direction is `ASCENDING`.

[#sorting-by-geo-distance]
=== Sorting by geographic distance

`SearchSort.byGeoDistance` tells the server to look at a field that has a geographic location, and sort the rows based on how far the field value is from some other location.

Required parameter:

* `field` -- Name of the field to use.
The field must be indexed as a geographic point.

* `location` -- The starting point for measuring distance.

Optional parameters:

* `direction` -- `ASCENDING` (near to far) or `DESCENDING` (far to near).
The default direction is `ASCENDING`.

* `unit` -- The `GeoDistanceUnit` to use for reporting the distance.
The default unit is `GeoDistanceUnit.METERS`.

[#sorting-by-string-syntax]
=== Sorting with string syntax

`SearchSort.by` lets you specify the sort using the syntax described in xref:{version-server}@server:fts/fts-search-response.adoc#sorting-with-strings[Sorting with Strings].
For example:

.Sorting with strings
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=sortWithStrings,indent=0]
----

[#multi-level-sorting]
=== More than one sort

You can join `SearchSort` objects to create a sort with more than one level.
Here are two examples that do the same thing in different ways:

.Multi-level sort using the `then` infix method
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=multiSortThen,indent=0]
----

.Multi-level sort using the `SearchSort.of` companion factory method
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=multiSortList,indent=0]
----

Both examples first sort the results by the value of the "country" field.
Rows with the same country value are sorted by document ID.

NOTE: The example for <<sorting-by-string-syntax>> also creates a multi-level sort.

[#pagination]
== Pagination

If you don't need all the result rows at once, you can ask the server to return one page of results.

The `searchQuery` method has a `limit` parameter that tells the server how many rows to return.
This is the page size.

There is also a `page` parameter that tells the server which rows to include in the results.

There are two ways to say which page to return.

[#offset-pagination]
=== Offset pagination

With offset pagination, you tell the server how many result rows to skip before it should start including rows in the result.

For example, this code skips the first 10 rows:

.Offset-based pagination
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=offsetPagination,indent=0]
----
<1> Offsets are zero-based, so this skips the first 10 rows.

This kind of pagination is unstable, because a row's offset can change if a different document is changed, added, or removed.
Imagine if this happens:

1. You ask for the first page, using offset 0 and limit 10.
2. Someone removes from Couchbase the document at offset 3.
3. You ask for the second page, using offset 10 and limit 10.

After step 2, the row that would have been the first row of the second page is now the last row of the first page.
Now in step 3, you don't see the row that "moved" to the first page.

Offset pagination can be expensive if the offset is very large.

[#keyset-pagination]
=== Keyset pagination

NOTE: Keyset pagination requires Couchbase Server 6.6.1 or later.

When the server sorts the search results, it assigns a "sort key" to each row.
The sort key is also called the "keyset".

With keyset pagination, you tell the server to return the page after (or before) a row whose keyset you remember from a previous search.

Here's an example that uses offset pagination to get the first page.
Then it uses keyset pagination to get the next page.

.Keyset-based pagination
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=keysetPagination,indent=0]
----
<1> Starting at offset 0 is the default.
You can remove this line.
<2> There is also a `searchBefore` method.
You can pass `SearchKeyset` or `SearchRow`.

Keyset pagination is less expensive than offset pagination when the offset is large.
Keyset pagination is stable if you are careful about sorting.
See the cautions below.

CAUTION: For stable keyset pagination, the `sort` argument must not let any two rows be equal.
It's good to always use a <<multi-level-sorting,multi-level sort>> that ends with `<<sorting-by-id,SearchSort.byId()>>`, so no two rows are equal.

CAUTION: Changing the sort invalidates a keyset (unless the new sort is the total opposite of the old sort).
If you use a keyset to search with a different sort, you will get bad results.

TIP: `keyset.serialize()` converts a keyset to a string, so you can send it to a client.
When you receive the string back from the client, pass it to the `SearchKeyset.deserialize` companion factory method to turn it back into a `SearchKeyset`.



[#total-rows]
=== Total number of rows

The search result metadata has a `totalRows` property that tells you how many rows matched the query, even if you limit the results to fewer rows.

.Getting the total number of rows
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=totalRows,indent=0]
----
<1> This can be greater than the `limit` argument.

[#compound-queries]
== Compound Queries

You can use boolean logic to combine queries into a "compound query."

Imagine Alice is searching for a hotel.
She would prefer a hotel with a sauna, but she would settle for a swimming pool.

Alice can use a `disjunction` query to search for "sauna" _or_ "pool".
She can _boost_ the "sauna" query, so hotels with a sauna get higher scores relative to other hotels.

."OR" query with boost
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=poolOrSauna,indent=0]
----
<1> There are other kinds of compound queries.
Use `conjunction` for "and".
Use `negation` for "not".
Use `boolean` for a complex query with "must", "should", and "mustNot" sub-queries.
<2> Alice thinks saunas are better than swimming pools, so she boosts this part of the query.

NOTE: Boosting a query has no effect unless the query is part of a compound query.

[#facets]
== Facets

A facet is like a histogram.
For each document matching the search query, the server inspects a field of the document to see which bin (or "category") the field value belongs to.

For `numeric` and `date` facets, you specify the categories up front as value ranges.
Common use cases include counting the number of documents in certain price ranges, like: $1 to $5, $5 to $20, $20+, or time ranges like: "today", "yesterday", or "more than a week ago".

Unlike a histogram, it's okay if the ranges overlap.
If a field value matches more than one range, each matching range has its count incremented.

For `term` facets, the server creates one category for each distinct value it sees in the field.

For example, let's say your documents have a "color" field where the value is one of "red", "green", or "blue".
The result of a term facet targeting the "color" field tells you the number of times each color appears as the field value.

Facets have a `size` parameter, which is an upper bound on the number of categories reported in the facet result.
For example, if you request a size of 3, the server will do its best to return the 3 largest categories.
To be more precise, it will select the top 3 categories from each partition executing the query, and then merge each partition's result into the final result.

CAUTION: If you are using multiple partitions and require an exact result, the size must be >= the number of categories; otherwise the result should be considered an estimate.

Facet results are not affected by query pagination.

To create a facet, use one of the `SearchFacet` companion factory methods.
To retrieve the result in a type-safe way, pass the facet to `SearchResult.get` (or `SearchMetadata.get`).
Alternatively, iterate over `SearchResult.facets` (or `SearchMetadata.facets`) and cast each `FacetResult` to the appropriate type.

CAUTION: Facets and/or ranges with no matching documents are omitted from the results.

This example uses the `beer-sample` bucket.
It requires an index called `beer-sample-index`, with fields "abv" and "category" indexed as stored fields.

.Searching with facets
[source,kotlin]
----
include::example$FullTextSearch.kt[tag=searchQueryWithFacets,indent=0]
----

[#streaming]
== Streaming

The previous examples store all result rows in memory.
If there are many rows, this can use a lot of memory.

To use less memory, pass a lambda to `execute` and work on each row one at a time, like this:

[source,kotlin]
----
include::example$FullTextSearch.kt[tag=streaming,indent=0]
----

NOTE: The streaming version of `execute` returns `SearchMetadata` instead of `SearchResult`.
